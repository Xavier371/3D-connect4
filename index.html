<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Connect 4</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 20px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #resetBtn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">3D Connect 4 - Your Turn</div>
    <button id="resetBtn">Reset Game</button>

    <script>
        // Game constants
        const BOARD_SIZE = 4;
        const CELL_SIZE = 1;
        const GAP = 0.2;
        
        // Game state
        let gameBoard = createEmptyBoard();
        let currentPlayer = 1; // 1 = Human (red), 2 = AI (blue)
        let gameOver = false;
        
        // Three.js variables
        let scene, camera, renderer;
        let controls;
        let columnHitboxes = [];
        let pieces = [];
        
        // Initialize the game
        init();
        animate();
        
        // Create empty 3D board array
        function createEmptyBoard() {
            return Array(BOARD_SIZE).fill().map(() => 
                   Array(BOARD_SIZE).fill().map(() => 
                   Array(BOARD_SIZE).fill(0)));
        }
        
        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 8;
            controls.maxDistance = 20;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            scene.add(directionalLight);
            
            // Create board
            createGrid();
            createClickableColumns();
            
            // Listen for window resize
            window.addEventListener('resize', onWindowResize);
            
            // Listen for mouse clicks
            window.addEventListener('click', onMouseClick);
            
            // Reset button
            document.getElementById('resetBtn').addEventListener('click', resetGame);
        }
        
        // Create the grid structure
        function createGrid() {
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            const gridPositions = [];
            const totalSize = BOARD_SIZE * (CELL_SIZE + GAP);
            
            // Horizontal grid lines (along X and Z)
            for (let y = 0; y <= BOARD_SIZE; y++) {
                const yPos = y * (CELL_SIZE + GAP) - totalSize / 2;
                
                for (let x = 0; x < BOARD_SIZE; x++) {
                    const xPos = x * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
                    
                    // Lines along Z
                    gridPositions.push(xPos, yPos, -totalSize / 2);
                    gridPositions.push(xPos, yPos, totalSize / 2);
                }
                
                for (let z = 0; z < BOARD_SIZE; z++) {
                    const zPos = z * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
                    
                    // Lines along X
                    gridPositions.push(-totalSize / 2, yPos, zPos);
                    gridPositions.push(totalSize / 2, yPos, zPos);
                }
            }
            
            // Vertical grid lines
            for (let x = 0; x <= BOARD_SIZE; x++) {
                const xPos = x * (CELL_SIZE + GAP) - totalSize / 2;
                
                for (let z = 0; z < BOARD_SIZE; z++) {
                    const zPos = z * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
                    
                    // Lines along Y
                    gridPositions.push(xPos, -totalSize / 2, zPos);
                    gridPositions.push(xPos, totalSize / 2, zPos);
                }
            }
            
            const gridGeometry = new THREE.BufferGeometry();
            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
            const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
            scene.add(grid);
        }
        
        // Create invisible hitboxes for column selection
        function createClickableColumns() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + GAP);
            
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    const geometry = new THREE.BoxGeometry(CELL_SIZE, totalSize, CELL_SIZE);
                    const material = new THREE.MeshBasicMaterial({ 
                        transparent: true, 
                        opacity: 0.0
                    });
                    
                    const hitbox = new THREE.Mesh(geometry, material);
                    const columnIndex = x * BOARD_SIZE + z;
                    hitbox.userData = { columnIndex };
                    
                    const xPos = x * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
                    const zPos = z * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
                    
                    hitbox.position.set(xPos, 0, zPos);
                    columnHitboxes.push(hitbox);
                    scene.add(hitbox);
                }
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Handle mouse click
        function onMouseClick(event) {
            if (gameOver || currentPlayer !== 1) return;
            
            // Calculate mouse position
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Set up raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with columns
            const intersects = raycaster.intersectObjects(columnHitboxes);
            
            if (intersects.length > 0) {
                const columnIndex = intersects[0].object.userData.columnIndex;
                makeMove(columnIndex, 1);
            }
        }
        
        // Make a move
        function makeMove(columnIndex, playerId) {
            if (gameOver) return;
            
            const x = Math.floor(columnIndex / BOARD_SIZE);
            const z = columnIndex % BOARD_SIZE;
            
            // Find lowest empty position in column
            let y = BOARD_SIZE - 1;
            while (y >= 0 && gameBoard[x][y][z] !== 0) {
                y--;
            }
            
            // If column is full, do nothing
            if (y < 0) {
                if (playerId === 1) {
                    updateInfo("Column is full! Try another.");
                }
                return false;
            }
            
            // Update game board
            gameBoard[x][y][z] = playerId;
            
            // Add piece
            addPiece(x, y, z, playerId);
            
            // Check for win
            if (checkWin(x, y, z, playerId)) {
                gameOver = true;
                if (playerId === 1) {
                    updateInfo("You win! Click Reset to play again.");
                } else {
                    updateInfo("AI wins! Click Reset to play again.");
                }
                return true;
            }
            
            // Check for draw
            if (checkDraw()) {
                gameOver = true;
                updateInfo("Draw! Click Reset to play again.");
                return true;
            }
            
            // Switch player
            if (playerId === 1) {
                currentPlayer = 2;
                updateInfo("AI is thinking...");
                
                // AI makes move after delay
                setTimeout(() => {
                    makeAIMove();
                }, 700);
            } else {
                currentPlayer = 1;
                updateInfo("Your turn");
            }
            
            return true;
        }
        
        // Add a piece to the board
        function addPiece(x, y, z, playerId) {
            const totalSize = BOARD_SIZE * (CELL_SIZE + GAP);
            const geometry = new THREE.SphereGeometry(CELL_SIZE / 2 - 0.05, 32, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: playerId === 1 ? 0xff4444 : 0x4444ff,
                shininess: 100
            });
            
            const piece = new THREE.Mesh(geometry, material);
            
            const xPos = x * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
            const yPos = y * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
            const zPos = z * (CELL_SIZE + GAP) - totalSize / 2 + CELL_SIZE / 2;
            
            piece.position.set(xPos, yPos, zPos);
            
            pieces.push({ piece, x, y, z });
            scene.add(piece);
        }
        
        // Make AI move
        function makeAIMove() {
            if (gameOver) return;
            
            // Simple AI - try to find winning move or block player's winning move
            let bestMove = findBestMove();
            
            // If no strategic move, choose random valid column
            if (bestMove === -1) {
                bestMove = getRandomValidMove();
            }
            
            // Make the move
            if (bestMove !== -1) {
                makeMove(bestMove, 2);
            }
        }
        
        // Find best move for AI
        function findBestMove() {
            // Try to find winning move
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Find lowest empty position
                let y = BOARD_SIZE - 1;
                while (y >= 0 && gameBoard[x][y][z] !== 0) {
                    y--;
                }
                
                if (y >= 0) {
                    // Temporarily make move
                    gameBoard[x][y][z] = 2;
                    
                    // Check if this is a winning move
                    if (checkWin(x, y, z, 2)) {
                        // Undo move
                        gameBoard[x][y][z] = 0;
                        return col;
                    }
                    
                    // Undo move
                    gameBoard[x][y][z] = 0;
                }
            }
            
            // Try to block player's winning move
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Find lowest empty position
                let y = BOARD_SIZE - 1;
                while (y >= 0 && gameBoard[x][y][z] !== 0) {
                    y--;
                }
                
                if (y >= 0) {
                    // Temporarily make move as player
                    gameBoard[x][y][z] = 1;
                    
                    // Check if this would be a winning move for player
                    if (checkWin(x, y, z, 1)) {
                        // Undo move
                        gameBoard[x][y][z] = 0;
                        return col;
                    }
                    
                    // Undo move
                    gameBoard[x][y][z] = 0;
                }
            }
            
            return -1;
        }
        
        // Get random valid move
        function getRandomValidMove() {
            const validMoves = [];
            
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Check if column has empty space
                if (gameBoard[x][0][z] === 0) {
                    validMoves.push(col);
                }
            }
            
            if (validMoves.length === 0) return -1;
            
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }
        
        // Check if the game is a draw
        function checkDraw() {
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    if (gameBoard[x][0][z] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Check if the last move resulted in a win
        function checkWin(x, y, z, player) {
            // All possible directions to check
            const directions = [
                [1,0,0], [-1,0,0],  // x axis
                [0,1,0], [0,-1,0],  // y axis
                [0,0,1], [0,0,-1],  // z axis
                
                [1,1,0], [-1,-1,0],  // xy diagonal
                [1,-1,0], [-1,1,0],  // xy diagonal
                
                [1,0,1], [-1,0,-1],  // xz diagonal
                [1,0,-1], [-1,0,1],  // xz diagonal
                
                [0,1,1], [0,-1,-1],  // yz diagonal
                [0,1,-1], [0,-1,1],  // yz diagonal
                
                [1,1,1], [-1,-1,-1],  // xyz diagonal
                [1,1,-1], [-1,-1,1],  // xyz diagonal
                [1,-1,1], [-1,1,-1],  // xyz diagonal
                [1,-1,-1], [-1,1,1]   // xyz diagonal
            ];
            
            // Check each direction
            for (let i = 0; i < directions.length; i += 2) {
                let count = 1;  // Start with 1 for the piece just placed
                
                // Check in positive direction
                let nx = x + directions[i][0];
                let ny = y + directions[i][1];
                let nz = z + directions[i][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    count++;
                    nx += directions[i][0];
                    ny += directions[i][1];
                    nz += directions[i][2];
                }
                
                // Check in negative direction
                nx = x + directions[i+1][0];
                ny = y + directions[i+1][1];
                nz = z + directions[i+1][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    count++;
                    nx += directions[i+1][0];
                    ny += directions[i+1][1];
                    nz += directions[i+1][2];
                }
                
                // If we found 4 in a row, highlight them and return true
                if (count >= 4) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Update info text
        function updateInfo(message) {
            document.getElementById('info').textContent = message;
        }
        
        // Reset the game
        function resetGame() {
            // Clear the board
            gameBoard = createEmptyBoard();
            
            // Remove all pieces
            for (const pieceObj of pieces) {
                scene.remove(pieceObj.piece);
            }
            pieces = [];
            
            // Reset game state
            currentPlayer = 1;
            gameOver = false;
            updateInfo("Your Turn");
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>