<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Connect 4</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #1a1a1e;
            font-family: Arial, sans-serif;
            touch-action: none; /* Prevent browser handling of touch gestures */
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 24px;
            z-index: 100;
        }
        #resetBtn, #modeBtn {
            position: absolute;
            bottom: 20px;
            padding: 15px 30px; /* Larger touch target */
            background-color: white;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.1s;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        #resetBtn {
            left: 50%;
            transform: translateX(-50%);
        }
        #modeBtn {
            right: 20px;
        }
        #resetBtn:hover {
            background-color: #f0f0f0;
            transform: translateX(-50%) scale(1.05);
        }
        #modeBtn:hover {
            background-color: #f0f0f0;
            transform: scale(1.05);
        }
        #resetBtn:active {
            background-color: #e0e0e0;
            transform: translateX(-50%) scale(0.98);
        }
        #modeBtn:active {
            background-color: #e0e0e0;
            transform: scale(0.98);
        }
        #modeBtn.active {
            background-color: #4488ff;
            color: white;
        }
        #controls {
            position: absolute;
            bottom: 80px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
        }
        #spacing-slider {
            width: 300px;
            height: 30px; /* Taller slider for easier touch */
            margin: 0 10px;
            cursor: pointer;
        }
        /* Media queries for mobile devices */
        @media (max-width: 768px) {
            #info {
                font-size: 20px;
                top: 5px;
            }
            #resetBtn, #modeBtn {
                bottom: 15px;
                padding: 8px 20px;
            }
            #modeBtn {
                right: 10px;
            }
            #controls {
                bottom: 70px;
            }
            #spacing-slider {
                width: 80%;
                max-width: 300px;
            }
            #resetButton {
                padding: 8px 20px;
                font-size: 14px;
            }
            .toggle-group button {
                padding: 8px 20px;
                font-size: 14px;
            }
        }
        /* Fix for iOS input styling */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 30px;
            width: 30px;
            border-radius: 15px;
            background: #ffffff;
            margin-top: -10px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 10px;
            background: #4444aa;
            border-radius: 5px;
        }
        #button-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }
        .toggle-group {
            display: flex;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        .toggle-group button {
            background-color: transparent;
            border: none;
            padding: 10px 25px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .toggle-group button.active {
            background-color: rgba(68, 136, 255, 0.8);
        }
        #resetButton {
            background-color: rgba(255, 90, 90, 0.8);
            border: none;
            color: white;
            padding: 12px 30px;
            font-weight: bold;
            font-size: 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        #resetButton:hover {
            background-color: rgba(255, 60, 60, 1);
        }
        /* Add player mode selector at top */
        #player-mode-container {
            position: absolute;
            top: 60px;
            right: 20px;
            z-index: 100;
        }
        #player-mode-group {
            display: flex;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        #player-mode-group button {
            background-color: transparent;
            border: none;
            padding: 10px 25px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #player-mode-group button.active {
            background-color: rgba(68, 136, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="info">3D Connect 4 - Your Turn</div>
    <div id="controls">
        <input type="range" id="spacing-slider" min="0" max="100" value="50">
    </div>
    <div id="button-container">
        <div class="toggle-group">
            <button id="onePlayerButton" class="active">1P</button>
            <button id="twoPlayerButton">2P</button>
        </div>
        <button id="resetButton">Reset Game</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Game constants
        const BOARD_SIZE = 4;
        const CELL_SIZE = 1;
        let SPACING = 0.3; // Adjustable spacing
        let GLOBAL_SCALE = 1.0; // Global scale factor for the entire scene
        
        // Game state
        let gameBoard = createEmptyBoard();
        let currentPlayer = 1; // 1 = Human (red), 2 = AI (blue)
        let gameOver = false;
        let isTwoPlayerMode = false; // Flag for game mode
        
        // Three.js variables
        let scene, camera, renderer;
        let controls;
        let cubes = [];
        let columnHitboxes = [];
        let pieces = [];
        
        // Add these variables to manage highlighting
        let hoveredColumn = null;
        let highlightedCubes = [];
        let activeColumn = -1; // Currently selected column
        
        // Add variables to track rotation
        let isRotating = false;
        let lastRotationTime = 0;
        const rotationCooldown = 300; // ms cooldown after rotation
        
        // Add more variables to track mouse/touch state
        let pointerIsDown = false;
        let pointerDownTime = 0;
        let pointerStartPosition = { x: 0, y: 0 };
        const dragThreshold = 5; // pixels
        
        // Add mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Store references to our event handlers so we can remove them later
        let clickHandler = null;
        let touchEndHandler = null;
        
        // Add a flag to track if a move is in progress
        let moveInProgress = false;
        
        // Initialize the game
        init();
        animate();
        
        // Create empty 3D board array
        function createEmptyBoard() {
            return Array(BOARD_SIZE).fill().map(() => 
                   Array(BOARD_SIZE).fill().map(() => 
                   Array(BOARD_SIZE).fill(0)));
        }
        
        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1e);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            
            // Create renderer with pixel ratio adjustment for mobile
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for better performance
            document.body.appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 6;
            controls.maxDistance = 20;
            
            // Limit vertical rotation to keep "up" as up
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI / 2;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 15);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Additional lights for better illumination
            const blueLight = new THREE.PointLight(0x0044ff, 0.5, 50);
            blueLight.position.set(-15, 10, -10);
            scene.add(blueLight);
            
            const redLight = new THREE.PointLight(0xff4400, 0.5, 50);
            redLight.position.set(15, 5, 10);
            scene.add(redLight);
            
            // Create board
            createGrid();
            const outerCube = createOuterCube();
            const axes = createAxes();
            createClickableColumns();
            
            // Listen for window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse and touch event listeners
            if (isMobile) {
                // Mobile-specific settings
                controls.rotateSpeed = 0.7; // Slower rotation for better control
                controls.enableZoom = true;
                controls.zoomSpeed = 0.5; // Slower zoom for better control
                
                // Touch events - only keep mousemove for hover effects
                window.addEventListener('touchstart', onPointerDown);
                window.addEventListener('touchmove', onMouseMove);
            } else {
                // Desktop events - only keep mousemove for hover effects
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mousedown', onPointerDown);
            }
            
            // Prevent context menu on right-click
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Reset button
            document.getElementById('resetButton').addEventListener('click', function(e) {
                // Stop event propagation to prevent clicks passing through to the game
                e.stopPropagation();
                resetGame();
            });
            document.getElementById('resetButton').addEventListener('touchend', function(e) {
                // Stop event propagation to prevent touches passing through to the game
                e.stopPropagation();
                e.preventDefault();
                resetGame();
            });
            
            // Two-player mode button
            document.getElementById('twoPlayerButton').addEventListener('click', function(e) {
                e.stopPropagation();
            });
            document.getElementById('twoPlayerButton').addEventListener('touchend', function(e) {
                e.stopPropagation();
                e.preventDefault();
            });
            
            // One-player mode button
            document.getElementById('onePlayerButton').addEventListener('click', function(e) {
                e.stopPropagation();
            });
            document.getElementById('onePlayerButton').addEventListener('touchend', function(e) {
                e.stopPropagation();
                e.preventDefault();
            });
            
            // Spacing slider
            document.getElementById('spacing-slider').addEventListener('input', (e) => {
                // Stop propagation to prevent clicks passing through
                e.stopPropagation();
                // Convert slider value (0-100) to a scale factor (0.5-1.5)
                GLOBAL_SCALE = 0.5 + (e.target.value / 100) * 1.0;
                updateSceneScale();
            });

            // Add event listeners to orbit controls to track rotation
            controls.addEventListener('start', () => {
                isRotating = true;
            });

            controls.addEventListener('end', () => {
                isRotating = false;
                lastRotationTime = Date.now();
            });

            // Apply initial scene scale
            updateSceneScale();

            // Initialize at document load
            document.addEventListener('DOMContentLoaded', function() {
                // Set the initial active button based on mode
                const onePlayerButton = document.getElementById('onePlayerButton');
                const twoPlayerButton = document.getElementById('twoPlayerButton');
                const resetButton = document.getElementById('resetButton');
                
                if (isTwoPlayerMode) {
                    twoPlayerButton.classList.add('active');
                    onePlayerButton.classList.remove('active');
                } else {
                    onePlayerButton.classList.add('active');
                    twoPlayerButton.classList.remove('active');
                }
                
                // Setup event listeners for buttons
                onePlayerButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    isTwoPlayerMode = false;
                    onePlayerButton.classList.add('active');
                    twoPlayerButton.classList.remove('active');
                    resetGame();
                    updateInfo("Player 1's Turn (Red)");
                });
                
                twoPlayerButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    isTwoPlayerMode = true;
                    twoPlayerButton.classList.add('active');
                    onePlayerButton.classList.remove('active');
                    resetGame();
                    updateInfo("Player 1's Turn (Red)");
                });
                
                resetButton.addEventListener('click', function(e) {
                    e.stopPropagation();
                    resetGame();
                    if (isTwoPlayerMode) {
                        updateInfo("Player 1's Turn (Red)");
                    } else {
                        updateInfo("Your Turn");
                    }
                });
            });
        }
        
        // Create the grid structure with cubes
        function createGrid() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let y = 0; y < BOARD_SIZE; y++) {
                    for (let z = 0; z < BOARD_SIZE; z++) {
                        // Create cube cell with completely transparent material
                        const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // Create edges with transparent material
                        const edges = new THREE.EdgesGeometry(geometry);
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x888888,
                            linewidth: 1.5,
                            transparent: true,
                            opacity: 0.0  // Start with completely transparent
                        });
                        
                        const line = new THREE.LineSegments(edges, lineMaterial);
                        
                        // Position the cube
                        const xPos = x * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                        const yPos = y * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                        const zPos = z * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                        
                        line.position.set(xPos, yPos, zPos);
                        line.userData = { x, y, z, originalColor: new THREE.Color(0x888888) };
                        
                        cubes.push(line);
                        scene.add(line);
                    }
                }
            }
        }
        
        // Update the entire scene scale - this replaces updateCubePositions
        function updateSceneScale() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            
            // Update cube positions
            for (const cube of cubes) {
                const { x, y, z } = cube.userData;
                const xPos = x * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                const yPos = y * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                const zPos = z * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                cube.position.set(xPos, yPos, zPos);
            }
            
            // Update hitbox positions
            updateColumnHitboxes();
            
            // Update pieces positions
            for (const pieceObj of pieces) {
                const { piece, x, y, z } = pieceObj;
                const xPos = x * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                const yPos = y * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                const zPos = z * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                piece.position.set(xPos, yPos, zPos);
            }
            
            // Scale the entire scene
            scene.scale.set(GLOBAL_SCALE, GLOBAL_SCALE, GLOBAL_SCALE);
        }
        
        // Update hitbox positions
        function updateColumnHitboxes() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            
            // Remove old hitboxes
            for (const hitbox of columnHitboxes) {
                scene.remove(hitbox);
            }
            columnHitboxes = [];
            
            // Create new hitboxes
            createClickableColumns();
        }
        
        // Create invisible hitboxes for column selection
        function createClickableColumns() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    // Use a slightly smaller hitbox for better precision
                    const hitboxSize = CELL_SIZE * 0.95;
                    const geometry = new THREE.BoxGeometry(hitboxSize, totalSize, hitboxSize);
                    const material = new THREE.MeshBasicMaterial({ 
                        transparent: true, 
                        opacity: 0.0
                    });
                    
                    const hitbox = new THREE.Mesh(geometry, material);
                    const columnIndex = x * BOARD_SIZE + z;
                    hitbox.userData = { columnIndex, x, z };
                    
                    const xPos = x * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                    const zPos = z * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
                    
                    hitbox.position.set(xPos, 0, zPos);
                    columnHitboxes.push(hitbox);
                    scene.add(hitbox);
                }
            }

            // IMPORTANT: Remove any existing event listeners to prevent duplicates
            if (clickHandler) {
                renderer.domElement.removeEventListener('click', clickHandler);
            }
            if (touchEndHandler) {
                renderer.domElement.removeEventListener('touchend', touchEndHandler);
            }

            // Define our new click handler
            clickHandler = function(event) {
                // Don't process clicks if the game is over
                if (gameOver) return;
                
                // In one-player mode, only player 1 can make clicks
                if (!isTwoPlayerMode && currentPlayer !== 1) return;
                
                // Don't process clicks during rotation
                if (isRotating) return;
                
                console.log("Handling click, current player:", currentPlayer);
                
                // Calculate mouse position for raycasting
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // Clear highlight
                clearHighlight();
                
                // Check for column hitboxes first - this is the most reliable method
                const intersectsColumns = raycaster.intersectObjects(columnHitboxes);
                if (intersectsColumns.length > 0) {
                    // Sort intersections by distance
                    intersectsColumns.sort((a, b) => a.distance - b.distance);
                    const columnIndex = intersectsColumns[0].object.userData.columnIndex;
                    console.log("Processing click on column:", columnIndex);
                    
                    // Make the move with current player
                    handleMoveAttempt(columnIndex);
                    return;
                }
                
                // Then check for cube intersections
                const intersectsCubes = raycaster.intersectObjects(cubes);
                if (intersectsCubes.length > 0) {
                    // Sort intersections by distance
                    intersectsCubes.sort((a, b) => a.distance - b.distance);
                    const cube = intersectsCubes[0].object;
                    const { x, z } = cube.userData;
                    const columnIndex = x * BOARD_SIZE + z;
                    
                    console.log("Processing click on cube:", columnIndex);
                    
                    // Make the move with current player
                    handleMoveAttempt(columnIndex);
                    return;
                }
                
                // If hoveredColumn is set, use that
                if (hoveredColumn !== null) {
                    console.log("Using hovered column:", hoveredColumn);
                    handleMoveAttempt(hoveredColumn);
                }
            };
            
            // Define our touch handler
            touchEndHandler = function(event) {
                // Don't process if game is over
                if (gameOver) return;
                
                // In one-player mode, only player 1 can make clicks
                if (!isTwoPlayerMode && currentPlayer !== 1) return;
                
                // Don't process during rotation
                if (isRotating) return;
                
                console.log("Handling touch, current player:", currentPlayer);
                
                // Prevent default to avoid double-firing
                event.preventDefault();
                
                // Process the touch if we have valid coordinates
                if (event.changedTouches && event.changedTouches.length > 0) {
                    const touch = event.changedTouches[0];
                    
                    // Calculate touch position
                    const mouse = new THREE.Vector2();
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Clear highlight
                    clearHighlight();
                    
                    // Check for column hitboxes first
                    const intersectsColumns = raycaster.intersectObjects(columnHitboxes);
                    if (intersectsColumns.length > 0) {
                        // Sort intersections by distance
                        intersectsColumns.sort((a, b) => a.distance - b.distance);
                        const columnIndex = intersectsColumns[0].object.userData.columnIndex;
                        console.log("Processing touch on column:", columnIndex);
                        
                        // Make the move with current player
                        handleMoveAttempt(columnIndex);
                        return;
                    }
                    
                    // Then check for cube intersections
                    const intersectsCubes = raycaster.intersectObjects(cubes);
                    if (intersectsCubes.length > 0) {
                        // Sort intersections by distance
                        intersectsCubes.sort((a, b) => a.distance - b.distance);
                        const cube = intersectsCubes[0].object;
                        const { x, z } = cube.userData;
                        const columnIndex = x * BOARD_SIZE + z;
                        
                        console.log("Processing touch on cube:", columnIndex);
                        
                        // Make the move with current player
                        handleMoveAttempt(columnIndex);
                        return;
                    }
                    
                    // If hoveredColumn is set, use that
                    if (hoveredColumn !== null) {
                        console.log("Using hovered column for touch:", hoveredColumn);
                        handleMoveAttempt(hoveredColumn);
                    }
                }
            };
            
            // Add our new event listeners
            renderer.domElement.addEventListener('click', clickHandler);
            renderer.domElement.addEventListener('touchend', touchEndHandler);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Update the mouse move handler to work with both mouse and touch events
        function onMouseMove(event) {
            // Allow highlighting for both players in two-player mode
            if (gameOver || (!isTwoPlayerMode && currentPlayer !== 1)) return;
            
            // Get the correct client coordinates
            let clientX, clientY;
            if (event.type === 'touchmove') {
                // Prevent default behavior (scrolling) for touch events
                event.preventDefault();
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            // Calculate mouse position
            const mouse = new THREE.Vector2();
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            // Set up raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // First check for column hitboxes - most accurate
            const intersectsColumns = raycaster.intersectObjects(columnHitboxes);
            
            if (intersectsColumns.length > 0) {
                // Sort intersections by distance to get the closest one
                intersectsColumns.sort((a, b) => a.distance - b.distance);
                const columnIndex = intersectsColumns[0].object.userData.columnIndex;
                
                // Only highlight if this is a different column
                if (hoveredColumn !== columnIndex) {
                    clearHighlight();
                    highlightColumn(columnIndex);
                    hoveredColumn = columnIndex;
                }
                return;
            }
            
            // If no hitboxes hit, try cubes as fallback
            const intersectsCubes = raycaster.intersectObjects(cubes);
            
            if (intersectsCubes.length > 0) {
                // Sort intersections by distance
                intersectsCubes.sort((a, b) => a.distance - b.distance);
                const cube = intersectsCubes[0].object;
                const { x, z } = cube.userData;
                const columnIndex = x * BOARD_SIZE + z;
                
                // Only highlight if this is a different column
                if (hoveredColumn !== columnIndex) {
                    clearHighlight();
                    highlightColumn(columnIndex);
                    hoveredColumn = columnIndex;
                }
            } else {
                // If nothing hit, clear highlight
                clearHighlight();
                hoveredColumn = null;
            }
        }
        
        // Update makeMove function to avoid flashing the grid
        function makeMove(columnIndex, playerId) {
            if (gameOver) return;
            
            const x = Math.floor(columnIndex / BOARD_SIZE);
            const z = columnIndex % BOARD_SIZE;
            
            // Find lowest empty position in column
            let y = 0;
            while (y < BOARD_SIZE && gameBoard[x][y][z] !== 0) {
                y++;
            }
            
            // If column is full, do nothing
            if (y >= BOARD_SIZE) {
                if (playerId === 1) {
                    updateInfo("Column is full! Try another.");
                }
                moveInProgress = false;
                return false;
            }
            
            // Clear highlight always
            clearHighlight();
            hoveredColumn = null;
            
            // Update game board
            gameBoard[x][y][z] = playerId;
            
            // Add piece
            addPiece(x, y, z, playerId);
            
            // Check for win
            if (checkWin(x, y, z, playerId)) {
                gameOver = true;
                
                // Find winning positions
                const winningPositions = getWinningPositions(x, y, z, playerId);
                
                // Highlight the winning pieces
                highlightWinningPieces(winningPositions);
                
                if (playerId === 1) {
                    updateInfo("Player 1 wins! Click Reset to play again.");
                } else {
                    if (isTwoPlayerMode) {
                        updateInfo("Player 2 wins! Click Reset to play again.");
                    } else {
                        updateInfo("AI wins! Click Reset to play again.");
                    }
                }
                moveInProgress = false;
                return true;
            }
            
            // Check for draw
            if (checkDraw()) {
                gameOver = true;
                updateInfo("Draw! Click Reset to play again.");
                moveInProgress = false;
                return true;
            }
            
            // Switch player
            if (playerId === 1) {
                currentPlayer = 2;
                
                if (isTwoPlayerMode) {
                    // In two-player mode, player 2's turn (blue)
                    updateInfo("Player 2's Turn (Blue)");
                    moveInProgress = false;
                } else {
                    // In one-player mode, have AI make a move
                    updateInfo("AI is thinking...");
                    
                    // AI makes move after delay
                    setTimeout(() => {
                        makeAIMove();
                        moveInProgress = false;
                    }, 700);
                }
            } else {
                currentPlayer = 1;
                updateInfo("Player 1's Turn (Red)");
                moveInProgress = false;
            }
            
            return true;
        }
        
        // Improved piece adding with better visuals and animation
        function addPiece(x, y, z, playerId) {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            const geometry = new THREE.SphereGeometry(CELL_SIZE / 2.5, 32, 32);
            
            // Improved materials with shininess
            const material = new THREE.MeshPhongMaterial({ 
                color: playerId === 1 ? 0xff4444 : 0x4444ff,
                shininess: 100,
                specular: 0x666666,
                emissive: playerId === 1 ? 0x330000 : 0x000033,
                emissiveIntensity: 0.2
            });
            
            const piece = new THREE.Mesh(geometry, material);
            
            // Start position (top of column)
            const xPos = x * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
            const topY = (BOARD_SIZE-1) * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
            const zPos = z * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
            
            // Target position
            const targetY = y * (CELL_SIZE + SPACING) - totalSize / 2 + CELL_SIZE / 2 + SPACING / 2;
            
            // Set initial position at the top of the column
            piece.position.set(xPos, topY, zPos);
            
            const pieceObj = { piece, x, y, z };
            pieces.push(pieceObj);
            scene.add(piece);
            
            // Animate the piece falling
            const duration = 500; // ms
            const startTime = Date.now();
            
            function animatePiece() {
                const elapsed = Date.now() - startTime;
                
                if (elapsed < duration) {
                    // Calculate position with easing
                    const t = elapsed / duration;
                    const easedT = 1 - Math.pow(1 - t, 3); // Cubic ease-out
                    
                    const currentY = topY + (targetY - topY) * easedT;
                    piece.position.y = currentY;
                    
                    // Continue animation
                    requestAnimationFrame(animatePiece);
                } else {
                    // Ensure final position is correct
                    piece.position.y = targetY;
                    
                    // Add small bounce effect
                    setTimeout(() => {
                        const bounceStartTime = Date.now();
                        const bounceDuration = 300;
                        
                        function animateBounce() {
                            const bounceElapsed = Date.now() - bounceStartTime;
                            
                            if (bounceElapsed < bounceDuration) {
                                const t = bounceElapsed / bounceDuration;
                                const bounce = Math.sin(t * Math.PI) * 0.1;
                                piece.position.y = targetY + bounce;
                                
                                requestAnimationFrame(animateBounce);
                            } else {
                                piece.position.y = targetY;
                            }
                        }
                        
                        animateBounce();
                    }, 50);
                }
            }
            
            animatePiece();
            
            return pieceObj;
        }
        
        // Make AI move
        function makeAIMove() {
            if (gameOver) return;
            
            // Simple AI - try to find winning move or block player's winning move
            let bestMove = findBestMove();
            
            // If no strategic move, choose random valid column
            if (bestMove === -1) {
                bestMove = getRandomValidMove();
            }
            
            // Make the move
            if (bestMove !== -1) {
                makeMove(bestMove, 2);
            }
        }
        
        // Find best move for AI
        function findBestMove() {
            // Try to find winning move
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Find lowest empty position
                let y = 0;
                while (y < BOARD_SIZE && gameBoard[x][y][z] !== 0) {
                    y++;
                }
                
                if (y < BOARD_SIZE) {
                    // Temporarily make move
                    gameBoard[x][y][z] = 2;
                    
                    // Check if this is a winning move
                    if (checkWin(x, y, z, 2)) {
                        // Undo move
                        gameBoard[x][y][z] = 0;
                        return col;
                    }
                    
                    // Undo move
                    gameBoard[x][y][z] = 0;
                }
            }
            
            // Try to block player's winning move
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Find lowest empty position
                let y = 0;
                while (y < BOARD_SIZE && gameBoard[x][y][z] !== 0) {
                    y++;
                }
                
                if (y < BOARD_SIZE) {
                    // Temporarily make move as player
                    gameBoard[x][y][z] = 1;
                    
                    // Check if this would be a winning move for player
                    if (checkWin(x, y, z, 1)) {
                        // Undo move
                        gameBoard[x][y][z] = 0;
                        return col;
                    }
                    
                    // Undo move
                    gameBoard[x][y][z] = 0;
                }
            }
            
            return -1;
        }
        
        // Get random valid move
        function getRandomValidMove() {
            const validMoves = [];
            
            for (let col = 0; col < BOARD_SIZE * BOARD_SIZE; col++) {
                const x = Math.floor(col / BOARD_SIZE);
                const z = col % BOARD_SIZE;
                
                // Check if column has empty space
                if (gameBoard[x][BOARD_SIZE-1][z] === 0) {
                    validMoves.push(col);
                }
            }
            
            if (validMoves.length === 0) return -1;
            
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }
        
        // Check if the game is a draw
        function checkDraw() {
            for (let x = 0; x < BOARD_SIZE; x++) {
                for (let z = 0; z < BOARD_SIZE; z++) {
                    if (gameBoard[x][BOARD_SIZE-1][z] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        // Check if the last move resulted in a win
        function checkWin(x, y, z, player) {
            // All possible directions to check
            const directions = [
                [1,0,0], [-1,0,0],  // x axis
                [0,1,0], [0,-1,0],  // y axis
                [0,0,1], [0,0,-1],  // z axis
                
                [1,1,0], [-1,-1,0],  // xy diagonal
                [1,-1,0], [-1,1,0],  // xy diagonal
                
                [1,0,1], [-1,0,-1],  // xz diagonal
                [1,0,-1], [-1,0,1],  // xz diagonal
                
                [0,1,1], [0,-1,-1],  // yz diagonal
                [0,1,-1], [0,-1,1],  // yz diagonal
                
                [1,1,1], [-1,-1,-1],  // xyz diagonal
                [1,1,-1], [-1,-1,1],  // xyz diagonal
                [1,-1,1], [-1,1,-1],  // xyz diagonal
                [1,-1,-1], [-1,1,1]   // xyz diagonal
            ];
            
            // Check each direction
            for (let i = 0; i < directions.length; i += 2) {
                let count = 1;  // Start with 1 for the piece just placed
                
                // Check in positive direction
                let nx = x + directions[i][0];
                let ny = y + directions[i][1];
                let nz = z + directions[i][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    count++;
                    nx += directions[i][0];
                    ny += directions[i][1];
                    ny += directions[i][2];
                }
                
                // Check in negative direction
                nx = x + directions[i+1][0];
                ny = y + directions[i+1][1];
                nz = z + directions[i+1][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    count++;
                    nx += directions[i+1][0];
                    ny += directions[i+1][1];
                    nz += directions[i+1][2];
                }
                
                // If we found 4 in a row, highlight them and return true
                if (count >= 4) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Update info text
        function updateInfo(message) {
            document.getElementById('info').textContent = message;
        }
        
        // Reset the game
        function resetGame() {
            // Clear the board
            gameBoard = createEmptyBoard();
            
            // Remove all pieces
            for (const pieceObj of pieces) {
                scene.remove(pieceObj.piece);
            }
            pieces = [];
            
            // Clear any highlighting
            clearHighlight();
            hoveredColumn = null;
            
            // Reset game state
            currentPlayer = 1;
            gameOver = false;
            moveInProgress = false; // Reset move in progress flag
            
            // Update the info message based on game mode
            if (isTwoPlayerMode) {
                updateInfo("Player 1's Turn (Red)");
            } else {
                updateInfo("Your Turn");
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Update highlightColumn function to show cubes only during hover
        function highlightColumn(columnIndex) {
            const x = Math.floor(columnIndex / BOARD_SIZE);
            const z = columnIndex % BOARD_SIZE;
            
            // Find the highest empty position
            let topEmptyY = -1;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (gameBoard[x][y][z] === 0) {
                    topEmptyY = y;
                    break;
                }
            }
            
            // Highlight all cubes in the column
            for (const cube of cubes) {
                const { x: cubeX, y: cubeY, z: cubeZ } = cube.userData;
                if (cubeX === x && cubeZ === z) {
                    // Make the cube visible
                    cube.material.opacity = 0.6;
                    
                    // Highlight the column
                    if (cubeY === topEmptyY) {
                        // Highlight the cube where the piece will be placed
                        cube.material.color.set(0x00ff00); // Bright green for target position
                        cube.material.opacity = 0.8; // More visible
                    } else {
                        // Highlight the column path
                        cube.material.color.set(0x4488ff); // Light blue for column
                    }
                    
                    highlightedCubes.push(cube);
                }
            }
        }

        // Update clearHighlight function to hide cubes again
        function clearHighlight() {
            for (const cube of highlightedCubes) {
                // Return to original color
                if (cube.userData.originalColor) {
                    cube.material.color.copy(cube.userData.originalColor);
                } else {
                    cube.material.color.set(0x888888); // Default color
                }
                
                // Make cube invisible again
                cube.material.opacity = 0.0;
            }
            highlightedCubes = [];
        }

        // Highlight winning pieces with animation
        function highlightWinningPieces(winningPositions) {
            for (const pos of winningPositions) {
                const { x, y, z } = pos;
                
                // Find the piece at this position
                for (const pieceObj of pieces) {
                    if (pieceObj.x === x && pieceObj.y === y && pieceObj.z === z) {
                        const piece = pieceObj.piece;
                        
                        // Change material to gold/yellow
                        piece.material = new THREE.MeshPhongMaterial({ 
                            color: 0xffdd44,
                            shininess: 100,
                            specular: 0xffffff,
                            emissive: 0x884400,
                            emissiveIntensity: 0.5
                        });
                        
                        // Add pulsing animation
                        const startScale = 1.0;
                        const maxScale = 1.2;
                        const pulseDuration = 1000; // ms
                        const startTime = Date.now();
                        
                        function animatePulse() {
                            const elapsed = Date.now() - startTime;
                            const t = (elapsed % pulseDuration) / pulseDuration;
                            
                            // Sine wave for smooth pulsing
                            const scale = startScale + (maxScale - startScale) * Math.sin(t * Math.PI);
                            piece.scale.set(scale, scale, scale);
                            
                            // Continue animation indefinitely
                            requestAnimationFrame(animatePulse);
                        }
                        
                        animatePulse();
                    }
                }
            }
        }

        // Add function to get winning positions
        function getWinningPositions(x, y, z, player) {
            // All possible directions to check
            const directions = [
                [1,0,0], [-1,0,0],  // x axis
                [0,1,0], [0,-1,0],  // y axis
                [0,0,1], [0,0,-1],  // z axis
                
                [1,1,0], [-1,-1,0],  // xy diagonal
                [1,-1,0], [-1,1,0],  // xy diagonal
                
                [1,0,1], [-1,0,-1],  // xz diagonal
                [1,0,-1], [-1,0,1],  // xz diagonal
                
                [0,1,1], [0,-1,-1],  // yz diagonal
                [0,1,-1], [0,-1,1],  // yz diagonal
                
                [1,1,1], [-1,-1,-1],  // xyz diagonal
                [1,1,-1], [-1,-1,1],  // xyz diagonal
                [1,-1,1], [-1,1,-1],  // xyz diagonal
                [1,-1,-1], [-1,1,1]   // xyz diagonal
            ];
            
            // Check each direction
            for (let i = 0; i < directions.length; i += 2) {
                const positions = [{x, y, z}];
                let count = 1;  // Start with 1 for the piece just placed
                
                // Check in positive direction
                let nx = x + directions[i][0];
                let ny = y + directions[i][1];
                let nz = z + directions[i][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    positions.push({x: nx, y: ny, z: nz});
                    count++;
                    nx += directions[i][0];
                    ny += directions[i][1];
                    nz += directions[i][2];
                }
                
                // Check in negative direction
                nx = x + directions[i+1][0];
                ny = y + directions[i+1][1];
                nz = z + directions[i+1][2];
                
                while (
                    nx >= 0 && nx < BOARD_SIZE &&
                    ny >= 0 && ny < BOARD_SIZE &&
                    nz >= 0 && nz < BOARD_SIZE &&
                    gameBoard[nx][ny][nz] === player
                ) {
                    positions.push({x: nx, y: ny, z: nz});
                    count++;
                    nx += directions[i+1][0];
                    ny += directions[i+1][1];
                    nz += directions[i+1][2];
                }
                
                // If we found 4 in a row, return the positions
                if (count >= 4) {
                    return positions;
                }
            }
            
            return [];
        }

        // Add new pointer down handler function for both mouse and touch
        function onPointerDown(event) {
            pointerIsDown = true;
            pointerDownTime = Date.now();
            
            // Get the correct position based on event type
            if (event.type === 'touchstart') {
                event.preventDefault(); // Prevent default behavior (scrolling)
                pointerStartPosition = { 
                    x: event.touches[0].clientX, 
                    y: event.touches[0].clientY 
                };
            } else {
                pointerStartPosition = { 
                    x: event.clientX, 
                    y: event.clientY 
                };
            }
        }

        // Create a simple wrapper around the makeMove function to ensure we only move once
        function handleMoveAttempt(columnIndex) {
            // Check if move is valid before attempting
            const x = Math.floor(columnIndex / BOARD_SIZE);
            const z = columnIndex % BOARD_SIZE;
            
            // If a move is already in progress, ignore this attempt
            if (moveInProgress) {
                console.log("Ignoring move attempt - move already in progress");
                return;
            }
            
            // Set the flag to prevent multiple moves
            moveInProgress = true;
            
            // Check if column is full
            let isValid = false;
            let lowestY = -1;
            for (let y = 0; y < BOARD_SIZE; y++) {
                if (gameBoard[x][y][z] === 0) {
                    isValid = true;
                    lowestY = y;
                    break;
                }
            }
            
            if (isValid) {
                // Make the move with current player
                makeMove(columnIndex, currentPlayer);
            } else {
                updateInfo("Column is full! Try another.");
                // Reset move in progress flag
                moveInProgress = false;
            }
        }

        // Update the createOuterCube function to make the grid outline fully visible
        function createOuterCube() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            
            // Create slightly larger cube to contain the entire grid
            const outerSize = totalSize + SPACING * 0.5;
            
            // Create the outer cube edges with thicker lines and high contrast
            const geometry = new THREE.BoxGeometry(outerSize, outerSize, outerSize);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffffff, // Pure white for maximum visibility
                linewidth: 4,    // Maximum line width 
                transparent: false, // No transparency for maximum contrast
                depthTest: false, // Always render on top
                depthWrite: false // Don't write to depth buffer
            });
            
            const outerCube = new THREE.LineSegments(edges, material);
            outerCube.position.set(0, 0, 0); // Center of the scene
            outerCube.renderOrder = 1000; // Ensure it's drawn on top of everything
            
            scene.add(outerCube);
            
            // Create a double-line effect with a slightly smaller black outline
            const innerGeometry = new THREE.BoxGeometry(outerSize - 0.02, outerSize - 0.02, outerSize - 0.02);
            const innerEdges = new THREE.EdgesGeometry(innerGeometry);
            const innerMaterial = new THREE.LineBasicMaterial({ 
                color: 0x000000, // Black inner line for contrast
                linewidth: 2,
                transparent: false,
                depthTest: false,
                depthWrite: false
            });
            
            const innerCube = new THREE.LineSegments(innerEdges, innerMaterial);
            innerCube.position.set(0, 0, 0);
            innerCube.renderOrder = 999; // Just under the outer cube
            
            scene.add(innerCube);
            
            // Create grid lines for each plane with improved visibility
            const gridHelper = new THREE.Group();
            
            // Fixed material for all grid lines to ensure visibility
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: 0xaaaaaa,
                transparent: true, 
                opacity: 0.7,  // Higher opacity for better visibility
                depthTest: false, // Disable depth testing to ensure visibility
                depthWrite: false,
                renderOrder: 900 // High render order but below outer cube
            });
            
            // Create explicit lines for each grid line instead of planes
            for (let i = 0; i <= BOARD_SIZE; i++) {
                const pos = (i * (CELL_SIZE + SPACING)) - totalSize / 2;
                const halfSize = outerSize / 2;
                
                // Only draw internal grid lines (skip the outer edges which are handled by the outer cube)
                if (i > 0 && i < BOARD_SIZE) {
                    // X-direction lines (4 lines per position)
                    // Front face
                    let lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        pos, -halfSize, -halfSize,
                        pos, -halfSize, halfSize
                    ], 3));
                    let line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Back face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        pos, halfSize, -halfSize,
                        pos, halfSize, halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Bottom face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        pos, -halfSize, -halfSize,
                        pos, halfSize, -halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Top face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        pos, -halfSize, halfSize,
                        pos, halfSize, halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Y-direction lines (4 lines per position)
                    // Front face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, pos, -halfSize,
                        halfSize, pos, -halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Back face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, pos, halfSize,
                        halfSize, pos, halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Left face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, pos, -halfSize,
                        -halfSize, pos, halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Right face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        halfSize, pos, -halfSize,
                        halfSize, pos, halfSize
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Z-direction lines (4 lines per position)
                    // Bottom face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, -halfSize, pos,
                        halfSize, -halfSize, pos
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Top face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, halfSize, pos,
                        halfSize, halfSize, pos
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Left face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        -halfSize, -halfSize, pos,
                        -halfSize, halfSize, pos
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                    
                    // Right face
                    lineGeometry = new THREE.BufferGeometry();
                    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
                        halfSize, -halfSize, pos,
                        halfSize, halfSize, pos
                    ], 3));
                    line = new THREE.Line(lineGeometry, gridMaterial);
                    gridHelper.add(line);
                }
            }
            
            scene.add(gridHelper);
            
            return { outerCube, innerCube, gridHelper };
        }

        // Update the createAxes function to make the axes more visible
        function createAxes() {
            const totalSize = BOARD_SIZE * (CELL_SIZE + SPACING);
            const axisLength = totalSize / 1.5;
            
            // Create axes with thicker lines
            const xAxisGeometry = new THREE.BufferGeometry();
            const yAxisGeometry = new THREE.BufferGeometry();
            const zAxisGeometry = new THREE.BufferGeometry();
            
            // Define start and end points
            const xPositions = [0, 0, 0, axisLength, 0, 0];
            const yPositions = [0, 0, 0, 0, axisLength, 0];
            const zPositions = [0, 0, 0, 0, 0, axisLength];
            
            xAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(xPositions, 3));
            yAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(yPositions, 3));
            zAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(zPositions, 3));
            
            // Create materials with brighter colors and higher linewidth
            const xMaterial = new THREE.LineBasicMaterial({ 
                color: 0xff0000,  // Bright red for X
                linewidth: 3
            }); 
            const yMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,  // Bright green for Y
                linewidth: 3
            }); 
            const zMaterial = new THREE.LineBasicMaterial({ 
                color: 0x0088ff,  // Bright blue for Z
                linewidth: 3
            });
            
            // Create lines
            const xAxis = new THREE.Line(xAxisGeometry, xMaterial);
            const yAxis = new THREE.Line(yAxisGeometry, yMaterial);
            const zAxis = new THREE.Line(zAxisGeometry, zMaterial);
            
            // Position at the bottom corner of the grid
            const offset = totalSize / 2 + SPACING;
            xAxis.position.set(-offset, -offset, -offset);
            yAxis.position.set(-offset, -offset, -offset);
            zAxis.position.set(-offset, -offset, -offset);
            
            // Set high renderOrder to ensure axes are always visible
            xAxis.renderOrder = 100;
            yAxis.renderOrder = 100;
            zAxis.renderOrder = 100;
            
            // Add to scene
            scene.add(xAxis);
            scene.add(yAxis);
            scene.add(zAxis);
            
            // Also add small cones at the end of each axis to indicate direction
            const coneHeight = 0.3;
            const coneRadius = 0.1;
            
            // X-axis cone (red)
            const xConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const xConeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xCone = new THREE.Mesh(xConeGeometry, xConeMaterial);
            xCone.position.set(-offset + axisLength, -offset, -offset);
            xCone.rotation.z = -Math.PI / 2;
            xCone.renderOrder = 100;
            
            // Y-axis cone (green)
            const yConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const yConeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yCone = new THREE.Mesh(yConeGeometry, yConeMaterial);
            yCone.position.set(-offset, -offset + axisLength, -offset);
            yCone.renderOrder = 100;
            
            // Z-axis cone (blue)
            const zConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
            const zConeMaterial = new THREE.MeshBasicMaterial({ color: 0x0088ff });
            const zCone = new THREE.Mesh(zConeGeometry, zConeMaterial);
            zCone.position.set(-offset, -offset, -offset + axisLength);
            zCone.rotation.x = Math.PI / 2;
            zCone.renderOrder = 100;
            
            scene.add(xCone);
            scene.add(yCone);
            scene.add(zCone);
            
            return { 
                lines: [xAxis, yAxis, zAxis], 
                cones: [xCone, yCone, zCone]
            };
        }
    </script>
</body>
</html> 
